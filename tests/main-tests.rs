use assert_cmd::Command;
use std::io::Write;
use tempfile::{NamedTempFile, TempPath};

fn rust_test_files() -> Vec<TempPath> {
    vec![
        include_str!("input/input1.rs"),
        include_str!("input/input2.rs"),
        include_str!("input/input3.rs"),
    ]
    .into_iter()
    .map(|content| {
        let mut file = NamedTempFile::new().unwrap();
        writeln!(file, "{}", content).unwrap();
        file.flush().unwrap();
        file.into_temp_path()
    })
    .collect()
}

#[test]
fn check_version() {
    let mut cmd = Command::cargo_bin("near-syn").unwrap();
    cmd.arg("--version")
        .assert()
        .code(0)
        .stdout(format!("near-syn {}\n", env!("CARGO_PKG_VERSION")));
}

mod ts {

    use super::rust_test_files;
    use assert_cmd::Command;

    fn output(defs: &str, name: &str, view_methods: &str, change_methods: &str) -> String {
        format!(
            include_str!("input/_template.ts"),
            env!("CARGO_PKG_VERSION"),
            env!("CARGO_PKG_REPOSITORY"),
            defs,
            name,
            view_methods
                .split_terminator(",")
                .map(|s| format!("\n        {:?},", s))
                .collect::<Vec<String>>()
                .join(""),
            change_methods
                .split_terminator(",")
                .map(|s| format!("\n        {:?},", s))
                .collect::<Vec<String>>()
                .join(""),
        )
    }

    fn near_ts() -> Command {
        let mut cmd = Command::cargo_bin("near-syn").unwrap();
        cmd.arg("ts");
        cmd.arg("--no-now");
        cmd
    }

    #[test]
    fn transpile_zero_rust_files_to_ts() {
        let mut cmd = near_ts();
        cmd.assert().code(0).stdout(output("", "", "", ""));
    }

    #[test]
    fn transpile_single_rust_file_to_ts() {
        let paths = rust_test_files();

        let mut cmd = near_ts();
        cmd.arg(paths[0].to_str().unwrap())
            .assert()
            .code(0)
            .stdout(output(
                include_str!("input/output1.ts"),
                "C",
                "get_f128,get_f128_other_way,another_impl,get",
                "set_f128,more_types,set_f128_with_sum",
            ));

        paths.into_iter().for_each(|path| path.close().unwrap());
    }

    #[test]
    fn transpile_multiple_rust_files_to_ts() {
        let paths = rust_test_files();

        let mut cmd = near_ts();
        cmd.args(&paths[1..]).assert().code(0).stdout(output(
            include_str!("input/output2.ts"),
            "S",
            "get",
            "",
        ));

        paths.into_iter().for_each(|path| path.close().unwrap());
    }
}
mod md {

    use super::rust_test_files;
    use assert_cmd::Command;

    fn output(text: &str) -> String {
        format!(
            r#"<!-- AUTOGENERATED doc, do not modify! -->
# Contract

| Method | Description | Return |
| ------ | ----------- | ------ |
{}
---

References

- :rocket: Initialization method. Needs to be called right after deployment.
- :eyeglasses: View only method, *i.e.*, does not modify the contract state.
- :writing_hand: Call method, i.e., does modify the contract state.
- &#x24C3; Payable method, i.e., call needs to have an attached NEAR deposit.

---

*This documentation was generated with* **near-syn v{}** <{}>
"#,
            text,
            env!("CARGO_PKG_VERSION"),
            env!("CARGO_PKG_REPOSITORY"),
        )
    }

    fn near_md() -> Command {
        let mut cmd = Command::cargo_bin("near-syn").unwrap();
        cmd.arg("md");
        cmd.arg("--no-now");
        cmd
    }

    #[test]
    fn transpile_zero_rust_files_to_md() {
        let mut cmd = near_md();
        cmd.assert().code(0).stdout(output("\n"));
    }

    #[test]
    fn transpile_single_rust_file_to_md() {
        let paths = rust_test_files();

        let mut cmd = near_md();
        cmd.arg(paths[0].to_str().unwrap())
        .assert()
        .code(0)
        .stdout(output(
            r#"| :rocket: `init_here` (*constructor*) |  init func | `Self` |
| :eyeglasses: `get_f128` |  Line 1 for get_f128 first  Line 2 for get_f128 second | `U128` |
| :writing_hand: `set_f128` |  Set f128. | `void` |
| :eyeglasses: `get_f128_other_way` |  | `U128` |
| :writing_hand: `more_types` |  | `void` |
| &#x24C3; `set_f128_with_sum` |  Pay to set f128. | `void` |
| :eyeglasses: `another_impl` |  another impl | `U128` |
| :eyeglasses: `get` |  Single-line comment for get | `U128` |


## Methods for C

### :rocket: `init_here` (*constructor*)

```typescript
init_here: { f128: U128 };
```

init func

### :eyeglasses: `get_f128`

```typescript
get_f128(): Promise<U128>;
```

Line 1 for get_f128 first
Line 2 for get_f128 second

### :writing_hand: `set_f128`

```typescript
set_f128(args: { value: U128 }, gas?: any): Promise<void>;
```

Set f128.

### :eyeglasses: `get_f128_other_way`

```typescript
get_f128_other_way(args: { key: U128 }): Promise<U128>;
```


### :writing_hand: `more_types`

```typescript
more_types(args: { key: U128, tuple: [string, number[]] }, gas?: any): Promise<void>;
```


### &#x24C3; `set_f128_with_sum`

```typescript
set_f128_with_sum(args: { a_value: U128, other_value: U128 }, gas?: any, amount?: any): Promise<void>;
```

Pay to set f128.

## Methods for C

### :eyeglasses: `another_impl`

```typescript
another_impl(args: { f128: U128 }): Promise<U128>;
```

another impl

## Methods for `I` interface

### :eyeglasses: `get`

```typescript
get(): Promise<U128>;
```

Single-line comment for get
"#,
        ));

        paths.into_iter().for_each(|path| path.close().unwrap());
    }
}
